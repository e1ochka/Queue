package org.example;

// Класс Queue представляет структуру данных очередь
public class Queue {
    private Node front; // Указатель на начало очереди
    private Node rear;  // Указатель на конец очереди

    // Конструктор класса Queue
    public Queue() {
        front = null; // Инициализация указателя начала очереди
        rear = null;  // Инициализация указателя конца очереди
    }

    // Метод для проверки, пуста ли очередь
    public boolean isEmpty() {
        return front == null; // Очередь пуста, если указатель начала не указывает на элемент
    }

    // Метод для добавления элемента в конец очереди
    public void enqueue(int data) {
        Node newNode = new Node(data); // Создание нового узла с переданными данными

        // Если очередь пуста, новый элемент становится началом и концом очереди
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode; // Установка ссылки на новый узел от текущего конечного узла
            rear = newNode;      // Перемещение указателя конца очереди на новый узел
        }
    }

    // Метод для извлечения элемента из начала очереди
    public int dequeue() {
        // Если очередь пуста, генерируется исключение
        if (isEmpty()) {
            throw new IllegalStateException("Очередь пуста");
        }
        int data = front.data;  // Получение данных из начала очереди
        front = front.next;     // Перемещение указателя начала на следующий элемент
        // Если после извлечения очередь оказалась пустой, обновляем указатель конца
        if (front == null) {
            rear = null;
        }
        return data;  // Возвращение данных извлеченного узла
    }

    // Вложенный класс для представления элементов очереди
    private class Node {
        private int data; // Данные хранимого элемента
        private Node next; // Ссылка на следующий узел

        // Конструктор класса Node для создания нового узла с переданными данными
        public Node(int data) {
            this.data = data;
            this.next = null; // Изначально новый узел не имеет следующего узла
        }
    }
}